# Data Access Layer - 数据访问层设计

**版本**: v1.0.0
**最后更新**: 2026-01-07
**维护人**: yangyangyang

---

## 目录

- [1. 概述](#1-概述)
- [2. 使用 goctl 生成 Model](#2-使用-goctl-生成-model)
- [3. DAO 设计](#3-dao-设计)
- [4. 事务处理](#4-事务处理)
- [5. 缓存策略](#5-缓存策略)
- [6. 错误处理](#6-错误处理)
- [7. 完整代码示例](#7-完整代码示例)

---

## 1. 概述

### 1.1 数据访问层架构

```
┌─────────────────────────────────────────┐
│      Business Logic Layer (业务逻辑)     │
└─────────────────────────────────────────┘
                   ↓
┌─────────────────────────────────────────┐
│       Data Access Layer (数据访问)        │
│  - TradeExecutionModel                  │
│  - OrderModel                           │
│  - ArbitrageOpportunityModel            │
│  - AccountBalanceModel                  │
│  - SystemConfigModel                    │
└─────────────────────────────────────────┘
                   ↓
┌─────────────────────────────────────────┐
│         Storage Layer (存储层)            │
│  - MySQL (go-zero Model)                │
│  - Redis (go-zero Cache)                │
└─────────────────────────────────────────┘
```

### 1.2 设计原则

1. **单一职责**：每个 Model 只负责一个表的 CRUD 操作
2. **依赖注入**：Model 通过 ServiceContext 注入到 Logic 层
3. **错误封装**：统一错误处理和日志记录
4. **事务管理**：使用 go-zero 的事务管理机制
5. **缓存优先**：热点数据优先使用 Redis 缓存

---

## 2. 使用 goctl 生成 Model

### 2.1 安装 goctl

```bash
# 安装 goctl 工具
go install github.com/zeromicro/go-zero/tools/goctl@latest

# 验证安装
goctl version
```

### 2.2 生成 Model 代码

#### 从数据库生成

```bash
# 生成所有表的 Model
goctl model mysql datasource \
  -url="arbitragex_user:ArbitrageX2025!@tcp(127.0.0.1:3306)/arbitragex" \
  -table="*" \
  -dir="./model" \
  -c=true

# 生成指定表的 Model
goctl model mysql datasource \
  -url="arbitragex_user:ArbitrageX2025!@tcp(127.0.0.1:3306)/arbitragex" \
  -table="trade_executions,orders" \
  -dir="./model" \
  -c=true

# 使用缓存
goctl model mysql datasource \
  -url="arbitragex_user:ArbitrageX2025!@tcp(127.0.0.1:3306)/arbitragex" \
  -table="*" \
  -dir="./model" \
  --cache
```

#### 生成的文件结构

```
model/
├── tradeexecutionsmodel.go          # TradeExecution Model
├── tradeexecmissions_gen.go         # 自动生成代码（不要修改）
├── ordermodel.go                    # Order Model
├── order_gen.go                     # 自动生成代码
├── arbitrageopportunitiesmodel.go   # ArbitrageOpportunity Model
├── arbitrageopportunities_gen.go    # 自动生成代码
├── accountbalancesmodel.go          # AccountBalance Model
├── accountbalances_gen.go           # 自动生成代码
├── systemconfigmodel.go             # SystemConfig Model
├── systemconfig_gen.go              # 自动生成代码
├── vars.go                          # 变量定义
└── error.go                         # 错误定义
```

### 2.3 生成的 Model 示例

#### 自动生成的代码（tradeexecutions_gen.go）

```go
// Code generated by goctl. DO NOT EDIT.
// Source: trade_executions table

package model

import (
    "database/sql"
    "fmt"
    "strings"
    "time"

    "github.com/zeromicro/go-zero/core/stores/cache"
    "github.com/zeromicro/go-zero/core/stores/sqlc"
    "github.com/zeromicro/go-zero/core/stores/sqlx"
)

var _ TradeExecutionsModel = (*customTradeExecutionsModel)(nil)

type (
    // TradeExecutionsModel 接口
    TradeExecutionsModel interface {
        Insert(ctx context.Context, data *TradeExecutions) error
        FindOne(ctx context.Context, id string) (*TradeExecutions, error)
        Update(ctx context.Context, data *TradeExecutions) error
        Delete(ctx context.Context, id string) error
        // ... 其他方法
    }

    customTradeExecutionsModel struct {
        *defaultTradeExecutionsModel
    }

    defaultTradeExecutionsModel struct {
        sqlc.CachedConn
        table string
    }
)

// NewTradeExecutionsModel 创建 Model
func NewTradeExecutionsModel(conn sqlx.SqlConn, c cache.CacheConf, opts ...cache.Option) TradeExecutionsModel {
    return &customTradeExecutionsModel{
        defaultTradeExecutionsModel: newTradeExecutionsModel(conn, c, opts...),
    }
}

func newTradeExecutionsModel(conn sqlx.SqlConn, c cache.CacheConf, opts ...cache.Option) *defaultTradeExecutionsModel {
    return &defaultTradeExecutionsModel{
        CachedConn: sqlc.NewConn(conn, c, opts...),
        table:      "`trade_executions`",
    }
}

// Insert 插入记录
func (m *defaultTradeExecutionsModel) Insert(ctx context.Context, data *TradeExecutions) error {
    query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, tradeexecutionsRowsExpectAutoSet)
    _, err := m.ExecNoCacheCtx(ctx, query, data.Id, data.OpportunityId, data.Symbol, data.BuyExchange, data.SellExchange, data.BuyPrice, data.SellPrice, data.Amount, data.EstProfit, data.ActualProfit, data.Status, data.ErrorMessage, data.StartedAt, data.CompletedAt)
    return err
}

// FindOne 查询单条记录
func (m *defaultTradeExecutionsModel) FindOne(ctx context.Context, id string) (*TradeExecutions, error) {
    query := fmt.Sprintf("SELECT %s FROM %s WHERE `id` = ? LIMIT 1", tradeexecutionsRows, m.table)
    var resp TradeExecutions
    err := m.QueryRowNoCacheCtx(ctx, &resp, query, id)
    switch err {
    case nil:
        return &resp, nil
    case sqlc.ErrNotFound:
        return nil, ErrNotFound
    default:
        return nil, err
    }
}

// Update 更新记录
func (m *defaultTradeExecutionsModel) Update(ctx context.Context, data *TradeExecutions) error {
    query := fmt.Sprintf("UPDATE %s SET %s WHERE `id` = ?", m.table, tradeexecutionsRowsWithPlaceHolder)
    _, err := m.ExecNoCacheCtx(ctx, query, data.OpportunityId, data.Symbol, data.BuyExchange, data.SellExchange, data.BuyPrice, data.SellPrice, data.Amount, data.EstProfit, data.ActualProfit, data.Status, data.ErrorMessage, data.StartedAt, data.CompletedAt, data.Id)
    return err
}

// Delete 删除记录
func (m *defaultTradeExecutionsModel) Delete(ctx context.Context, id string) error {
    query := fmt.Sprintf("DELETE FROM %s WHERE `id` = ?", m.table)
    _, err := m.ExecNoCacheCtx(ctx, query, id)
    return err
}
```

#### 自定义代码（tradeexecutionsmodel.go）

```go
package model

import (
    "context"
    "database/sql"
    "fmt"
    "strings"
    "time"

    "github.com/zeromicro/go-zero/core/stores/cache"
    "github.com/zeromicro/go-zero/core/stores/sqlc"
    "github.com/zeromicro/go-zero/core/stores/sqlx"
)

type (
    // TradeExecutionsModel 接口扩展
    customTradeExecutionsModel struct {
        *defaultTradeExecutionsModel
    }
)

// FindByStatus 根据状态查询
func (m *customTradeExecutionsModel) FindByStatus(ctx context.Context, status string) ([]*TradeExecutions, error) {
    query := fmt.Sprintf("SELECT %s FROM %s WHERE `status` = ? ORDER BY `started_at` DESC", tradeexecutionsRows, m.table)
    var resp []*TradeExecutions
    err := m.QueryRowsNoCacheCtx(ctx, &resp, query, status)
    return resp, err
}

// FindBySymbol 根据交易对查询
func (m *customTradeExecutionsModel) FindBySymbol(ctx context.Context, symbol string, limit int) ([]*TradeExecutions, error) {
    query := fmt.Sprintf("SELECT %s FROM %s WHERE `symbol` = ? ORDER BY `started_at` DESC LIMIT ?", tradeexecutionsRows, m.table)
    var resp []*TradeExecutions
    err := m.QueryRowsNoCacheCtx(ctx, &resp, query, symbol, limit)
    return resp, err
}

// FindByTimeRange 根据时间范围查询
func (m *customTradeExecutionsModel) FindByTimeRange(ctx context.Context, startTime, endTime time.Time) ([]*TradeExecutions, error) {
    query := fmt.Sprintf("SELECT %s FROM %s WHERE `started_at` BETWEEN ? AND ? ORDER BY `started_at` DESC", tradeexecutionsRows, m.table)
    var resp []*TradeExecutions
    err := m.QueryRowsNoCacheCtx(ctx, &resp, query, startTime, endTime)
    return resp, err
}

// UpdateStatus 更新状态
func (m *customTradeExecutionsModel) UpdateStatus(ctx context.Context, id string, status string) error {
    query := fmt.Sprintf("UPDATE %s SET `status` = ?, `updated_at` = ? WHERE `id` = ?", m.table)
    _, err := m.ExecNoCacheCtx(ctx, query, status, time.Now(), id)
    return err
}

// UpdateActualProfit 更新实际收益
func (m *customTradeExecutionsModel) UpdateActualProfit(ctx context.Context, id string, actualProfit float64, completedAt time.Time) error {
    query := fmt.Sprintf("UPDATE %s SET `actual_profit` = ?, `completed_at` = ?, `status` = 'completed', `updated_at` = ? WHERE `id` = ?", m.table)
    _, err := m.ExecNoCacheCtx(ctx, query, actualProfit, completedAt, time.Now(), id)
    return err
}

// GetStatistics 获取统计信息
func (m *customTradeExecutionsModel) GetStatistics(ctx context.Context, startTime, endTime time.Time) (*Statistics, error) {
    query := `
        SELECT
            COUNT(*) as total_trades,
            SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed_trades,
            SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed_trades,
            SUM(est_profit) as total_est_profit,
            SUM(actual_profit) as total_actual_profit,
            AVG(CASE WHEN actual_profit > 0 THEN actual_profit END) as avg_profit
        FROM %s
        WHERE started_at BETWEEN ? AND ?
    `
    var stats Statistics
    err := m.QueryRowNoCacheCtx(ctx, &stats, fmt.Sprintf(query, m.table), startTime, endTime)
    return &stats, err
}

type Statistics struct {
    TotalTrades      int64   `db:"total_trades"`
    CompletedTrades  int64   `db:"completed_trades"`
    FailedTrades     int64   `db:"failed_trades"`
    TotalEstProfit   float64 `db:"total_est_profit"`
    TotalActualProfit float64 `db:"total_actual_profit"`
    AvgProfit        float64 `db:"avg_profit"`
}
```

---

## 3. DAO 设计

### 3.1 DAO 接口定义

#### TradeExecutionDAO

```go
// package dao
package dao

import (
    "context"
    "time"

    "arbitragex/model"
)

// TradeExecutionDAO 交易执行 DAO
type TradeExecutionDAO struct {
    model *model.TradeExecutionsModel
}

// NewTradeExecutionDAO 创建 DAO
func NewTradeExecutionDAO(model *model.TradeExecutionsModel) *TradeExecutionDAO {
    return &TradeExecutionDAO{model: model}
}

// Create 创建交易执行记录
func (d *TradeExecutionDAO) Create(ctx context.Context, execution *model.TradeExecutions) error {
    return d.model.Insert(ctx, execution)
}

// GetByID 根据 ID 获取
func (d *TradeExecutionDAO) GetByID(ctx context.Context, id string) (*model.TradeExecutions, error) {
    return d.model.FindOne(ctx, id)
}

// GetByStatus 根据状态获取列表
func (d *TradeExecutionDAO) GetByStatus(ctx context.Context, status string) ([]*model.TradeExecutions, error) {
    return d.model.FindByStatus(ctx, status)
}

// GetBySymbol 根据交易对获取列表
func (d *TradeExecutionDAO) GetBySymbol(ctx context.Context, symbol string, limit int) ([]*model.TradeExecutions, error) {
    return d.model.FindBySymbol(ctx, symbol, limit)
}

// GetByTimeRange 根据时间范围获取列表
func (d *TradeExecutionDAO) GetByTimeRange(ctx context.Context, startTime, endTime time.Time) ([]*model.TradeExecutions, error) {
    return d.model.FindByTimeRange(ctx, startTime, endTime)
}

// UpdateStatus 更新状态
func (d *TradeExecutionDAO) UpdateStatus(ctx context.Context, id string, status string) error {
    return d.model.UpdateStatus(ctx, id, status)
}

// UpdateActualProfit 更新实际收益
func (d *TradeExecutionDAO) UpdateActualProfit(ctx context.Context, id string, actualProfit float64, completedAt time.Time) error {
    return d.model.UpdateActualProfit(ctx, id, actualProfit, completedAt)
}

// GetStatistics 获取统计信息
func (d *TradeExecutionDAO) GetStatistics(ctx context.Context, startTime, endTime time.Time) (*model.Statistics, error) {
    return d.model.GetStatistics(ctx, startTime, endTime)
}

// List 分页查询
func (d *TradeExecutionDAO) List(ctx context.Context, page, pageSize int) ([]*model.TradeExecutions, error) {
    offset := (page - 1) * pageSize
    query := fmt.Sprintf("SELECT %s FROM %s ORDER BY started_at DESC LIMIT ? OFFSET ?", tradeexecutionsRows, d.model.table())
    var resp []*model.TradeExecutions
    err := d.model.QueryRowsNoCacheCtx(ctx, &resp, query, pageSize, offset)
    return resp, err
}
```

#### OrderDAO

```go
// OrderDAO 订单 DAO
type OrderDAO struct {
    model *model.OrdersModel
}

// NewOrderDAO 创建 DAO
func NewOrderDAO(model *model.OrdersModel) *OrderDAO {
    return &OrderDAO{model: model}
}

// Create 创建订单
func (d *OrderDAO) Create(ctx context.Context, order *model.Orders) error {
    return d.model.Insert(ctx, order)
}

// GetByID 根据 ID 获取
func (d *OrderDAO) GetByID(ctx context.Context, id string) (*model.Orders, error) {
    return d.model.FindOne(ctx, id)
}

// GetByExecutionID 根据执行 ID 获取订单列表
func (d *OrderDAO) GetByExecutionID(ctx context.Context, executionID string) ([]*model.Orders, error) {
    return d.model.FindByExecutionId(ctx, executionID)
}

// UpdateStatus 更新订单状态
func (d *OrderDAO) UpdateStatus(ctx context.Context, id string, status string) error {
    return d.model.UpdateStatus(ctx, id, status)
}

// UpdateFilledAmount 更新成交数量
func (d *OrderDAO) UpdateFilledAmount(ctx context.Context, id string, filledAmount float64, avgPrice float64) error {
    return d.model.UpdateFilledAmount(ctx, id, filledAmount, avgPrice)
}
```

### 3.2 DAO 在 Logic 层使用

#### 在 ServiceContext 中注册 DAO

```go
// internal/svc/servicecontext.go
package svc

import (
    "arbitragex/internal/config"
    "arbitragex/model"
    "arbitragex/internal/dao"
)

type ServiceContext struct {
    Config config.Config

    // DAOs
    TradeExecutionDAO *dao.TradeExecutionDAO
    OrderDAO          *dao.OrderDAO
    ArbitrageDAO      *dao.ArbitrageOpportunityDAO
    AccountBalanceDAO *dao.AccountBalanceDAO
    SystemConfigDAO   *dao.SystemConfigDAO
}

func NewServiceContext(c config.Config) *ServiceContext {
    // 创建 MySQL 连接
    conn := sqlx.NewMysql(c.Mysql.DataSource)

    // 创建 Redis 缓存
    cacheConf := cache.RedisConf{
        Host: c.Redis.Host,
        Type: c.Redis.Type,
    }
    cache := cache.New(cacheConf, cache.WithExpiry(time.Minute * 5))

    // 创建 Models
    tradeExecutionModel := model.NewTradeExecutionsModel(conn, cache)
    orderModel := model.NewOrdersModel(conn, cache)
    arbitrageModel := model.NewArbitrageOpportunitiesModel(conn, cache)
    accountBalanceModel := model.NewAccountBalancesModel(conn, cache)
    systemConfigModel := model.NewSystemConfigModel(conn, cache)

    return &ServiceContext{
        Config:            c,
        TradeExecutionDAO: dao.NewTradeExecutionDAO(tradeExecutionModel),
        OrderDAO:          dao.NewOrderDAO(orderModel),
        ArbitrageDAO:      dao.NewArbitrageOpportunityDAO(arbitrageModel),
        AccountBalanceDAO: dao.NewAccountBalanceDAO(accountBalanceModel),
        SystemConfigDAO:   dao.NewSystemConfigDAO(systemConfigModel),
    }
}
```

#### 在 Logic 中使用 DAO

```go
// internal/logic/tradeexecutionlogic.go
package logic

import (
    "context"
    "time"

    "arbitragex/internal/svc"
    "arbitragex/internal/types"
    "arbitragex/model"
)

type TradeExecutionLogic struct {
    logx.Logger
    ctx    context.Context
    svcCtx *svc.ServiceContext
}

func NewTradeExecutionLogic(ctx context.Context, svcCtx *svc.ServiceContext) *TradeExecutionLogic {
    return &TradeExecutionLogic{
        Logger: logx.WithContext(ctx),
        ctx:    ctx,
        svcCtx: svcCtx,
    }
}

// CreateExecution 创建交易执行记录
func (l *TradeExecutionLogic) CreateExecution(req *types.CreateExecutionReq) (string, error) {
    // 生成 ID
    id := generateID()

    // 创建记录
    execution := &model.TradeExecutions{
        Id:            id,
        OpportunityId: req.OpportunityId,
        Symbol:        req.Symbol,
        BuyExchange:   req.BuyExchange,
        SellExchange:  req.SellExchange,
        BuyPrice:      req.BuyPrice,
        SellPrice:     req.SellPrice,
        Amount:        req.Amount,
        EstProfit:     req.EstProfit,
        Status:        "pending",
        StartedAt:     time.Now(),
    }

    // 使用 DAO 插入
    if err := l.svcCtx.TradeExecutionDAO.Create(l.ctx, execution); err != nil {
        l.Errorf("创建交易执行记录失败: %v", err)
        return "", err
    }

    l.Infof("交易执行记录创建成功: %s", id)
    return id, nil
}

// UpdateExecutionStatus 更新执行状态
func (l *TradeExecutionLogic) UpdateExecutionStatus(id string, status string) error {
    if err := l.svcCtx.TradeExecutionDAO.UpdateStatus(l.ctx, id, status); err != nil {
        l.Errorf("更新执行状态失败: %v", err)
        return err
    }

    l.Infof("执行状态已更新: %s -> %s", id, status)
    return nil
}

// CompleteExecution 完成执行
func (l *TradeExecutionLogic) CompleteExecution(id string, actualProfit float64) error {
    if err := l.svcCtx.TradeExecutionDAO.UpdateActualProfit(l.ctx, id, actualProfit, time.Now()); err != nil {
        l.Errorf("更新实际收益失败: %v", err)
        return err
    }

    l.Infof("执行已完成: %s, 实际收益: %f", id, actualProfit)
    return nil
}

// GetExecutionStatistics 获取统计信息
func (l *TradeExecutionLogic) GetExecutionStatistics(startTime, endTime time.Time) (*model.Statistics, error) {
    stats, err := l.svcCtx.TradeExecutionDAO.GetStatistics(l.ctx, startTime, endTime)
    if err != nil {
        l.Errorf("获取统计信息失败: %v", err)
        return nil, err
    }

    return stats, nil
}
```

---

## 4. 事务处理

### 4.1 go-zero 事务管理

#### 基本事务

```go
import (
    "github.com/zeromicro/go-zero/core/stores/sqlx"
)

// ExecuteTradeWithTransaction 使用事务执行交易
func (l *TradeExecutionLogic) ExecuteTradeWithTransaction(req *types.TradeRequest) error {
    // 开启事务
    err := l.svcCtx.TradeExecutionModel.TransactCtx(l.ctx, func(ctx context.Context, session sqlx.Session) error {
        // 1. 创建交易执行记录
        execution := &model.TradeExecutions{
            Id:            generateID(),
            OpportunityId: req.OpportunityId,
            Symbol:        req.Symbol,
            // ... 其他字段
        }

        if err := l.svcCtx.TradeExecutionModel.InsertCtx(ctx, session, execution); err != nil {
            return err
        }

        // 2. 创建买入订单
        buyOrder := &model.Orders{
            Id:          generateID(),
            ExecutionId: execution.Id,
            Exchange:    req.BuyExchange,
            Side:        "buy",
            // ... 其他字段
        }

        if err := l.svcCtx.OrderModel.InsertCtx(ctx, session, buyOrder); err != nil {
            return err
        }

        // 3. 创建卖出订单
        sellOrder := &model.Orders{
            Id:          generateID(),
            ExecutionId: execution.Id,
            Exchange:    req.SellExchange,
            Side:        "sell",
            // ... 其他字段
        }

        if err := l.svcCtx.OrderModel.InsertCtx(ctx, session, sellOrder); err != nil {
            return err
        }

        // 4. 更新账户余额
        if err := l.svcCtx.AccountBalanceDAO.UpdateBalanceCtx(ctx, session, req.BuyExchange, req.Symbol, -req.Amount); err != nil {
            return err
        }

        // 事务成功提交
        return nil
    })

    if err != nil {
        l.Errorf("交易执行失败: %v", err)
        return err
    }

    l.Info("交易执行成功")
    return nil
}
```

#### 嵌套事务

```go
// ExecuteComplexTrade 执行复杂交易（嵌套事务）
func (l *TradeExecutionLogic) ExecuteComplexTrade(req *types.ComplexTradeRequest) error {
    // 外层事务
    err := l.svcCtx.TradeExecutionModel.TransactCtx(l.ctx, func(ctx context.Context, session sqlx.Session) error {
        // 1. 创建主交易记录
        execution := &model.TradeExecutions{...}
        if err := l.svcCtx.TradeExecutionModel.InsertCtx(ctx, session, execution); err != nil {
            return err
        }

        // 2. 执行子交易（使用嵌套事务）
        for _, subTrade := range req.SubTrades {
            if err := l.executeSubTrade(ctx, session, execution.Id, subTrade); err != nil {
                return err // 任何子交易失败，整个事务回滚
            }
        }

        return nil
    })

    return err
}

// executeSubTrade 执行子交易
func (l *TradeExecutionLogic) executeSubTrade(ctx context.Context, session sqlx.Session, executionID string, subTrade *types.SubTrade) error {
    // 在同一个事务中执行
    buyOrder := &model.Orders{
        Id:          generateID(),
        ExecutionId: executionID,
        // ... 其他字段
    }

    if err := l.svcCtx.OrderModel.InsertCtx(ctx, session, buyOrder); err != nil {
        return err
    }

    // ... 其他操作

    return nil
}
```

### 4.2 事务隔离级别

```go
// SetTransactionIsolation 设置事务隔离级别
func (m *TradeExecutionsModel) TransactCtxWithIsolation(ctx context.Context, isolation sql.IsolationLevel, fn func(ctx context.Context, session sqlx.Session) error) error {
    conn, err := m.GetConn()
    if err != nil {
        return err
    }

    session := sqlx.NewSession(conn)
    session.SetIsolation(isolation)

    err = session.TransactCtx(ctx, func(ctx context.Context, session sqlx.Session) error {
        return fn(ctx, session)
    })

    return err
}

// 使用示例
err := l.svcCtx.TradeExecutionModel.TransactCtxWithIsolation(l.ctx, sql.LevelSerializable, func(ctx context.Context, session sqlx.Session) error {
    // 事务操作
    return nil
})
```

---

## 5. 缓存策略

### 5.1 Redis 缓存配置

#### 在 Model 中启用缓存

```go
// 创建带缓存的 Model
func NewTradeExecutionsModel(conn sqlx.SqlConn, c cache.CacheConf, opts ...cache.Option) TradeExecutionsModel {
    return &customTradeExecutionsModel{
        defaultTradeExecutionsModel: newTradeExecutionsModel(conn, c, opts...),
    }
}
```

#### ServiceContext 配置

```go
// internal/svc/servicecontext.go
func NewServiceContext(c config.Config) *ServiceContext {
    // 创建 Redis 缓存
    cacheConf := cache.RedisConf{
        Host: c.Redis.Host,
        Type: c.Redis.Type,
        Pass: c.Redis.Pass,
    }

    // 缓存配置
    cacheOpts := []cache.Option{
        cache.WithExpiry(time.Minute * 5),      // 5 分钟过期
        cache.WithCacheNotFoundExpiry(time.Minute * 1), // 未命中缓存 1 分钟
    }

    cache := cache.New(cacheConf, cacheOpts...)

    // 创建 Model（自动启用缓存）
    tradeExecutionModel := model.NewTradeExecutionsModel(conn, cache, cacheOpts...)

    return &ServiceContext{...}
}
```

### 5.2 缓存键设计

```go
// package cache
package cache

const (
    // 交易执行缓存
    TradeExecutionKey    = "trade:execution:%s"        // trade:execution:{id}
    TradeExecutionListKey = "trade:execution:list:%s"   // trade:execution:list:{status}

    // 订单缓存
    OrderKey             = "trade:order:%s"            // trade:order:{id}
    OrderExecutionKey    = "trade:order:execution:%s"  // trade:order:execution:{execution_id}

    // 套利机会缓存
    ArbitrageOpportunityKey = "trade:arbitrage:%s"      // trade:arbitrage:{id}
    ArbitrageListKey       = "trade:arbitrage:list"    // trade:arbitrage:list

    // 账户余额缓存
    AccountBalanceKey      = "account:balance:%s:%s"   // account:balance:{exchange}:{currency}

    // 系统配置缓存
    SystemConfigKey        = "system:config:%s"        // system:config:{key}
)

// BuildCacheKey 构建缓存键
func BuildCacheKey(pattern string, args ...interface{}) string {
    return fmt.Sprintf(pattern, args...)
}
```

### 5.3 缓存操作

#### 设置缓存

```go
// SetTradeExecutionCache 设置交易执行缓存
func (d *TradeExecutionDAO) SetTradeExecutionCache(ctx context.Context, execution *model.TradeExecutions) error {
    key := cache.BuildCacheKey(cache.TradeExecutionKey, execution.Id)

    data, err := json.Marshal(execution)
    if err != nil {
        return err
    }

    return d.cache.Set(ctx, key, string(data))
}

// GetTradeExecutionCache 获取交易执行缓存
func (d *TradeExecutionDAO) GetTradeExecutionCache(ctx context.Context, id string) (*model.TradeExecutions, error) {
    key := cache.BuildCacheKey(cache.TradeExecutionKey, id)

    data, err := d.cache.Get(ctx, key)
    if err != nil {
        return nil, err
    }

    var execution model.TradeExecutions
    if err := json.Unmarshal([]byte(data), &execution); err != nil {
        return nil, err
    }

    return &execution, nil
}

// DeleteTradeExecutionCache 删除交易执行缓存
func (d *TradeExecutionDAO) DeleteTradeExecutionCache(ctx context.Context, id string) error {
    key := cache.BuildCacheKey(cache.TradeExecutionKey, id)
    return d.cache.Del(ctx, key)
}
```

#### 缓存穿透保护

```go
// GetByIDWithCache 带缓存保护的查询
func (d *TradeExecutionDAO) GetByIDWithCache(ctx context.Context, id string) (*model.TradeExecutions, error) {
    // 1. 尝试从缓存获取
    cached, err := d.GetTradeExecutionCache(ctx, id)
    if err == nil {
        return cached, nil
    }

    // 2. 从数据库查询
    execution, err := d.GetByID(ctx, id)
    if err != nil {
        // 缓存空值防止穿透
        d.cache.Set(ctx, cache.BuildCacheKey(cache.TradeExecutionKey, id), "")
        return nil, err
    }

    // 3. 写入缓存
    d.SetTradeExecutionCache(ctx, execution)

    return execution, nil
}
```

### 5.4 缓存更新策略

#### Cache-Aside 模式

```go
// UpdateStatusWithCache 更新状态（Cache-Aside）
func (d *TradeExecutionDAO) UpdateStatusWithCache(ctx context.Context, id string, status string) error {
    // 1. 更新数据库
    if err := d.UpdateStatus(ctx, id, status); err != nil {
        return err
    }

    // 2. 删除缓存（下次读取时重新加载）
    if err := d.DeleteTradeExecutionCache(ctx, id); err != nil {
        logx.Errorf("删除缓存失败: %v", err)
        // 不影响主流程
    }

    return nil
}
```

#### Write-Through 模式

```go
// UpdateStatusWithWriteThrough 更新状态（Write-Through）
func (d *TradeExecutionDAO) UpdateStatusWithWriteThrough(ctx context.Context, id string, status string) error {
    // 1. 更新数据库
    if err := d.UpdateStatus(ctx, id, status); err != nil {
        return err
    }

    // 2. 立即更新缓存
    execution, err := d.GetByID(ctx, id)
    if err != nil {
        return err
    }

    if err := d.SetTradeExecutionCache(ctx, execution); err != nil {
        logx.Errorf("更新缓存失败: %v", err)
    }

    return nil
}
```

---

## 6. 错误处理

### 6.1 错误定义

```go
// common/errors/code.go
package errors

const (
    // 成功
    OK = 0

    // 数据库错误 (5000-5999)
    DBError           = 5000
    DBNotFoundError   = 5001
    DBDuplicateError  = 5002
    DBUpdateError     = 5003
    DBDeleteError     = 5004
    DBTransactionError = 5005
)

// 错误信息映射
var CodeMsg = map[int]string{
    OK:                "成功",
    DBError:           "数据库错误",
    DBNotFoundError:   "记录不存在",
    DBDuplicateError:  "记录重复",
    DBUpdateError:     "更新失败",
    DBDeleteError:     "删除失败",
    DBTransactionError: "事务错误",
}
```

### 6.2 错误处理

```go
// HandleDBError 处理数据库错误
func HandleDBError(err error) error {
    if err == nil {
        return nil
    }

    // 判断错误类型
    if errors.Is(err, sqlc.ErrNotFound) {
        return code.NewCodeError(code.DBNotFoundError, "记录不存在")
    }

    if strings.Contains(err.Error(), "Duplicate entry") {
        return code.NewCodeError(code.DBDuplicateError, "记录重复")
    }

    // 默认数据库错误
    return code.NewCodeError(code.DBError, err.Error())
}

// 使用示例
func (d *TradeExecutionDAO) GetByID(ctx context.Context, id string) (*model.TradeExecutions, error) {
    execution, err := d.model.FindOne(ctx, id)
    if err != nil {
        return nil, HandleDBError(err)
    }
    return execution, nil
}
```

### 6.3 重试机制

```go
// RetryWithBackoff 带退避的重试
func RetryWithBackoff(fn func() error, maxRetries int) error {
    var err error
    for i := 0; i < maxRetries; i++ {
        if err = fn(); err == nil {
            return nil
        }

        // 指数退避
        backoffTime := time.Duration(1<<uint(i)) * time.Second
        time.Sleep(backoffTime)
    }

    return fmt.Errorf("重试 %d 次后仍然失败: %v", maxRetries, err)
}

// 使用示例
func (d *TradeExecutionDAO) CreateWithRetry(ctx context.Context, execution *model.TradeExecutions) error {
    err := RetryWithBackoff(func() error {
        return d.Create(ctx, execution)
    }, 3)

    return err
}
```

---

## 7. 完整代码示例

### 7.1 完整的 TradeExecutionLogic

```go
// internal/logic/tradeexecutionlogic.go
package logic

import (
    "context"
    "encoding/json"
    "fmt"
    "time"

    "arbitragex/internal/svc"
    "arbitragex/internal/types"
    "arbitragex/model"
    "arbitragex/common/errors"
    "arbitragex/common/cache"

    "github.com/zeromicro/go-zero/core/logx"
)

type TradeExecutionLogic struct {
    logx.Logger
    ctx    context.Context
    svcCtx *svc.ServiceContext
}

func NewTradeExecutionLogic(ctx context.Context, svcCtx *svc.ServiceContext) *TradeExecutionLogic {
    return &TradeExecutionLogic{
        Logger: logx.WithContext(ctx),
        ctx:    ctx,
        svcCtx: svcCtx,
    }
}

// ExecuteTrade 执行交易（完整流程）
func (l *TradeExecutionLogic) ExecuteTrade(req *types.ExecuteTradeReq) (*types.ExecuteTradeResp, error) {
    // 1. 参数验证
    if req.Amount <= 0 {
        return nil, errors.NewCodeError(errors.InvalidParam, "金额必须大于 0")
    }

    // 2. 风险检查
    if err := l.riskCheck(req); err != nil {
        return nil, err
    }

    // 3. 创建交易执行记录（事务开始）
    executionID, err := l.createExecutionRecord(req)
    if err != nil {
        return nil, err
    }

    // 4. 执行交易
    result, err := l.executeTrade(executionID, req)
    if err != nil {
        l.UpdateExecutionStatus(executionID, "failed")
        return nil, err
    }

    // 5. 更新执行结果
    if err := l.CompleteExecution(executionID, result.ActualProfit); err != nil {
        l.Errorf("更新执行结果失败: %v", err)
    }

    return &types.ExecuteTradeResp{
        ExecutionId: executionID,
        Status:      "completed",
        ActualProfit: result.ActualProfit,
    }, nil
}

// createExecutionRecord 创建执行记录（事务）
func (l *TradeExecutionLogic) createExecutionRecord(req *types.ExecuteTradeReq) (string, error) {
    var executionID string

    err := l.svcCtx.TradeExecutionModel.TransactCtx(l.ctx, func(ctx context.Context, session sqlx.Session) error {
        // 生成 ID
        executionID = generateID()

        // 创建执行记录
        execution := &model.TradeExecutions{
            Id:            executionID,
            OpportunityId: req.OpportunityId,
            Symbol:        req.Symbol,
            BuyExchange:   req.BuyExchange,
            SellExchange:  req.SellExchange,
            BuyPrice:      req.BuyPrice,
            SellPrice:     req.SellPrice,
            Amount:        req.Amount,
            EstProfit:     req.EstProfit,
            Status:        "pending",
            StartedAt:     time.Now(),
        }

        if err := l.svcCtx.TradeExecutionModel.InsertCtx(ctx, session, execution); err != nil {
            return fmt.Errorf("创建执行记录失败: %w", err)
        }

        // 创建买入订单
        buyOrder := &model.Orders{
            Id:          generateID(),
            ExecutionId: executionID,
            Exchange:    req.BuyExchange,
            Symbol:      req.Symbol,
            Side:        "buy",
            Type:        "limit",
            Price:       req.BuyPrice,
            Amount:      req.Amount,
            Status:      "pending",
            CreatedAt:   time.Now(),
            UpdatedAt:   time.Now(),
        }

        if err := l.svcCtx.OrderModel.InsertCtx(ctx, session, buyOrder); err != nil {
            return fmt.Errorf("创建买入订单失败: %w", err)
        }

        // 创建卖出订单
        sellOrder := &model.Orders{
            Id:          generateID(),
            ExecutionId: executionID,
            Exchange:    req.SellExchange,
            Symbol:      req.Symbol,
            Side:        "sell",
            Type:        "limit",
            Price:       req.SellPrice,
            Amount:      req.Amount,
            Status:      "pending",
            CreatedAt:   time.Now(),
            UpdatedAt:   time.Now(),
        }

        if err := l.svcCtx.OrderModel.InsertCtx(ctx, session, sellOrder); err != nil {
            return fmt.Errorf("创建卖出订单失败: %w", err)
        }

        return nil
    })

    if err != nil {
        return "", err
    }

    return executionID, nil
}

// riskCheck 风险检查
func (l *TradeExecutionLogic) riskCheck(req *types.ExecuteTradeReq) error {
    // 1. 检查账户余额
    balance, err := l.svcCtx.AccountBalanceDAO.GetBalance(l.ctx, req.BuyExchange, "USDT")
    if err != nil {
        return fmt.Errorf("获取余额失败: %w", err)
    }

    requiredAmount := req.BuyPrice * req.Amount
    if balance.Available < requiredAmount {
        return errors.NewCodeError(errors.InsufficientBalance, "余额不足")
    }

    // 2. 检查熔断器
    if !l.svcCtx.CircuitBreaker.CanTrade() {
        return errors.NewCodeError(errors.CircuitBreakerOpen, "熔断器已触发")
    }

    // 3. 检查价格合理性
    if req.BuyPrice <= 0 || req.SellPrice <= 0 {
        return errors.NewCodeError(errors.InvalidPrice, "价格无效")
    }

    // 4. 检查收益率
    priceDiffRate := (req.SellPrice - req.BuyPrice) / req.BuyPrice
    if priceDiffRate < l.svcCtx.Config.MinProfitRate {
        return errors.NewCodeError(errors.LowProfitRate, "收益率过低")
    }

    return nil
}

// executeTrade 执行交易
func (l *TradeExecutionLogic) executeTrade(executionID string, req *types.ExecuteTradeReq) (*ExecutionResult, error) {
    // 更新状态为执行中
    l.UpdateExecutionStatus(executionID, "executing")

    // 并发执行买入和卖出
    var wg sync.WaitGroup
    var buyResult, sellResult *OrderResult
    var buyErr, sellErr error

    // 买入
    wg.Add(1)
    go func() {
        defer wg.Done()
        buyResult, buyErr = l.executeBuy(executionID, req)
    }()

    // 卖出
    wg.Add(1)
    go func() {
        defer wg.Done()
        sellResult, sellErr = l.executeSell(executionID, req)
    }()

    wg.Wait()

    // 处理结果
    if buyErr != nil || sellErr != nil {
        // 尝试回滚
        if buyResult != nil && buyResult.Status == "filled" {
            l.rollbackBuy(executionID, buyResult)
        }
        return nil, fmt.Errorf("交易执行失败: buyErr=%v, sellErr=%v", buyErr, sellErr)
    }

    // 计算实际收益
    actualProfit := sellResult.FilledAmount * sellResult.AvgPrice -
                   buyResult.FilledAmount * buyResult.AvgPrice -
                   buyResult.Fee - sellResult.Fee

    return &ExecutionResult{
        ActualProfit: actualProfit,
        BuyOrder:     buyResult,
        SellOrder:    sellResult,
    }, nil
}

// executeBuy 执行买入
func (l *TradeExecutionLogic) executeBuy(executionID string, req *types.ExecuteTradeReq) (*OrderResult, error) {
    // 调用交易所 API
    exchange := l.svcCtx.ExchangeManager.GetExchange(req.BuyExchange)
    orderID, err := exchange.PlaceOrder(&PlaceOrderRequest{
        Symbol: req.Symbol,
        Side:   "buy",
        Price:  req.BuyPrice,
        Amount: req.Amount,
    })

    if err != nil {
        return nil, err
    }

    // 轮询订单状态
    for i := 0; i < 10; i++ {
        order, err := exchange.GetOrder(orderID)
        if err != nil {
            continue
        }

        if order.Status == "filled" {
            // 更新订单状态
            l.svcCtx.OrderDAO.UpdateFilledAmount(l.ctx, order.ID, order.FilledAmount, order.AvgPrice)

            return &OrderResult{
                OrderID:      order.ID,
                Status:       order.Status,
                FilledAmount: order.FilledAmount,
                AvgPrice:     order.AvgPrice,
                Fee:          order.Fee,
            }, nil
        }

        time.Sleep(time.Second)
    }

    return nil, fmt.Errorf("买入订单超时")
}

// executeSell 执行卖出
func (l *TradeExecutionLogic) executeSell(executionID string, req *types.ExecuteTradeReq) (*OrderResult, error) {
    // 类似 executeBuy
    // ...
}

// rollbackBuy 回滚买入
func (l *TradeExecutionLogic) rollbackBuy(executionID string, buyOrder *OrderResult) error {
    // 执行卖出回滚
    exchange := l.svcCtx.ExchangeManager.GetExchange(buyOrder.Exchange)

    _, err := exchange.PlaceOrder(&PlaceOrderRequest{
        Symbol: buyOrder.Symbol,
        Side:   "sell",
        Price:  buyOrder.AvgPrice,
        Amount: buyOrder.FilledAmount,
    })

    if err != nil {
        l.Errorf("回滚买入失败: %v", err)
        return err
    }

    l.Infof("回滚买入成功: %s", executionID)
    return nil
}

// generateID 生成 ID
func generateID() string {
    return fmt.Sprintf("%d", time.Now().UnixNano())
}

type ExecutionResult struct {
    ActualProfit float64
    BuyOrder     *OrderResult
    SellOrder    *OrderResult
}

type OrderResult struct {
    OrderID      string
    Status       string
    FilledAmount float64
    AvgPrice     float64
    Fee          float64
}
```

---

## 附录

### A. 相关文档

- [Schema_Design.md](./Schema_Design.md) - 数据库表结构设计
- [Database_TechStack.md](../TechStack/Database_TechStack.md) - 数据库技术栈
- [Backend_TechStack.md](../TechStack/Backend_TechStack.md) - 后端技术栈

### B. 最佳实践

1. **使用 goctl 生成 Model**：避免手写重复代码
2. **DAO 层封装业务逻辑**：保持 Model 层简洁
3. **事务操作尽量小**：避免长事务
4. **合理使用缓存**：热点数据优先缓存
5. **错误处理统一**：使用错误码和错误消息映射
6. **重试机制**：对于临时性错误使用重试

### C. 常见问题

**Q1: goctl 生成的代码可以修改吗？**
A: `_gen.go` 文件不要修改，`model.go` 文件可以添加自定义方法。

**Q2: 如何处理缓存穿透？**
A: 缓存空值，设置较短的过期时间。

**Q3: 事务失败会自动回滚吗？**
A: 是的，go-zero 的 TransactCtx 会自动回滚。

**Q4: 如何提高数据库性能？**
A: 使用索引、优化查询、使用缓存、读写分离。

---

**最后更新**: 2026-01-07
**版本**: v1.0.0
